cmake_minimum_required(VERSION 3.18.1)

project("dn_ffmepg_player")

add_library(dn_ffmepg_player
        SHARED
        dn_ffmepg_player.c)


# 获取目录上一级的做法
# https://cloud.tencent.com/developer/ask/sof/46411
# 参数1：接收参数名称
# 参数2：需要操作的路径，在路径后面加 /.. ，类似 linux 的 .. ,就是返回上级
# 参数3: ABSOLUTE 表示绝对路径
#get_filename_component(VAR_PARENT ${CMAKE_CURRENT_SOURCE_DIR}/.. ABSOLUTE)

# 声明变量 third_part_jni_path、third_part_header_path
# ../jni 表示当前路径的上一级路径，之后上一级路径查找子目录 jni
#set(third_part_jni_path ../jni)

# 将绝对路径赋值给：third_part_jni_path
get_filename_component(third_part_jni_path ${CMAKE_CURRENT_SOURCE_DIR}/../jni ABSOLUTE)

#使用 MESSAGE 命令输出调试信息，打印 third_part_jni_path 变量的值。
MESSAGE("third_part_jni_path = ${third_part_jni_path}")
# 头部文件所在的目录： 设置 third_part_header_path 变量的值为 third_part_jni_path 变量的值附加 /include 后缀。
set(third_part_header_path ${third_part_jni_path}/include)
# so 库所存在的文件夹
set(third_part_lib_path  ${third_part_jni_path}/${CMAKE_ANDROID_ARCH_ABI})
# 使用 MESSAGE 命令输出调试信息，打印 third_part_lib_path 变量的值。
MESSAGE("shenlong ${third_part_lib_path}")

# ${CMAKE_ANDROID_ARCH_ABI} 是获取 Cpu 架构的
MESSAGE("HI ${CMAKE_ANDROID_ARCH_ABI}")
# 设置扫描 so 库对应的请求头目录
INCLUDE_DIRECTORIES(${third_part_header_path})

##################################################################

// aux_source_directory: 是 CMake 提供的函数，用于将指定目录下的源文件自动添加到变量中。
//   （${CMAKE_SOURCE_DIR}: 是 CMake 预定义的变量，表示当前 CMakeLists.txt 文件所在的源码根目录路径。SRC_LIST: 是用户指定的变量名，用于存储找到的源文件列表）
aux_source_directory(${CMAKE_SOURCE_DIR} SRC_LIST)

##################################################################

find_library( # Sets the name of the path variable.
        log-lib

        # Specifies the name of the NDK library that
        # you want CMake to locate.
        log)

# 导入 ffmpeg 相关的动态库
# 1、导入 avcodec
# add_library
# 参数1：库的名称
# 参数2：表示共享库
# 参数3：表示导入
add_library(avcodec SHARED IMPORTED)
# set_target_properties
# 参数1：库的名称
# 参数2：表示设置路径的属性，就是导入本地路径
# 参数3：本地路径
set_target_properties(avcodec
        PROPERTIES IMPORTED_LOCATION
        ${third_part_lib_path}/libavcodec-56.so)

# 2、导入 avdevice
add_library(avdevice
        SHARED
        IMPORTED)
set_target_properties(avdevice
        PROPERTIES IMPORTED_LOCATION
        ${third_part_lib_path}/libavdevice-56.so)

# 3、导入 avfilter
add_library(avfilter
        SHARED
        IMPORTED)
set_target_properties(avfilter
        PROPERTIES IMPORTED_LOCATION
        ${third_part_lib_path}/libavfilter-5.so)
# 4、导入 avformat
add_library(avformat
        SHARED
        IMPORTED)
set_target_properties(avformat
        PROPERTIES IMPORTED_LOCATION
        ${third_part_lib_path}/libavformat-56.so)
# 5、导入 avutil
add_library(avutil
        SHARED
        IMPORTED)
set_target_properties(avutil
        PROPERTIES IMPORTED_LOCATION
        ${third_part_lib_path}/libavutil-54.so)
# 6、导入 postproc
add_library(postproc
        SHARED
        IMPORTED)
set_target_properties(postproc
        PROPERTIES IMPORTED_LOCATION
        ${third_part_lib_path}/libpostproc-53.so)
# 7、导入 swresample
add_library(swresample
        SHARED
        IMPORTED)
set_target_properties(swresample
        PROPERTIES IMPORTED_LOCATION
        ${third_part_lib_path}/libswresample-1.so)
# 8、导入 swscale
add_library(swscale
        SHARED
        IMPORTED)
set_target_properties(swscale
        PROPERTIES IMPORTED_LOCATION
        ${third_part_lib_path}/libswscale-3.so)

##################################################################

# 添加共享库搜索路径
# 可以代替
#add_library(avcodec SHARED IMPORTED)
#set_target_properties(avcodec
#        PROPERTIES IMPORTED_LOCATION
#        ${third_part_lib_path}/libavcodec-56.so)
# 没有效果, 不知道是不是 so 要放到 jniLibs 目录
# 官方是不推荐使用这个的, 官方推荐使用 推荐使用find_package和find_library寻找共享库的绝对路径，再传给target_link_libraries使用
#link_directories(${path_lib_ffmpeg}/${CMAKE_ANDROID_ARCH_ABI})

# 批量导入库
# 获取指定路径的 so 库, 放到 SO_PATH_LIST 集合中
FILE(GLOB SO_PATH_LIST "${path_lib_ffmpeg_libs}/${CMAKE_ANDROID_ARCH_ABI}/*.so")
# 循环 SO_PATH_LIST 集合
foreach(_SO_PATH ${SO_PATH_LIST})
#    从路径中截取文件名称
    STRING(REGEX REPLACE ".+/(.+)\\..*" "\\1" SO_NAME ${_SO_PATH})
#   将文件名称拼接到新的集合 GAME_SOURCE_MINE 里面
    list(APPEND SO_NAME_LIST ${SO_NAME})
#    导入第三方库(ffmpeg)
    add_library(${SO_NAME} SHARED IMPORTED)
#    第三方库的本地路径
    set_target_properties(${SO_NAME}
            PROPERTIES IMPORTED_LOCATION
            ${_SO_PATH})
endforeach()
#  打印 GAME_SOURCE_MINE 集合
MESSAGE("tianshenkk ${SO_NAME_LIST}")

##################################################################

# 将我们自己编写的库与第三方库进行关联
target_link_libraries(
        dn_ffmepg_player
        avcodec
        avdevice
        avfilter
        avformat
        avutil
        postproc
        swresample
        swscale

        ${log-lib}
)

